"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Printer = void 0;
var _PrinterWrapper = require("./PrinterWrapper.js");
var _index = require("./constants/index.js");
var _index2 = require("./printHelpers/index.js");
class Printer {
  static instances = new Map();
  constructor({
    target,
    deviceName,
    lang = _index.PrinterModelLang.MODEL_ANK
  }) {
    if (Printer.instances.has(target)) {
      return Printer.instances.get(target);
    }
    this.deviceName = deviceName;
    this.lang = lang;
    this.printerWrapper = new _PrinterWrapper.PrinterWrapper(target);
    this.initQueue();
    Printer.instances.set(target, this);
  }
  initQueue() {
    const PQueue = require('p-queue/dist').default;
    this.queue = new PQueue({
      concurrency: 1
    });
  }
  addQueueTask(task) {
    return this.queue.add(task);
  }
  static addTextLine = _index2.addTextLine;
  static monitorPrinter = _index2.monitorPrinter;
  static tryToConnectUntil = _index2.tryToConnectUntil;
  static addViewShot = _index2.addViewShot;
  get currentFontWidth() {
    return this.printerWrapper.currentFontWidth;
  }
  init = () => {
    return this.printerWrapper.init({
      deviceName: this.deviceName,
      lang: this.lang
    });
  };
  connect = async timeout => {
    await this.init();
    return this.printerWrapper.connect(timeout);
  };
  disconnect = () => {
    return this.printerWrapper.disconnect();
  };
  addText = data => {
    return this.printerWrapper.addText(data);
  };
  addFeedLine = line => {
    return this.printerWrapper.addFeedLine(line);
  };
  addLineSpace = linespc => {
    return this.printerWrapper.addLineSpace(linespc);
  };
  sendData = timeout => {
    return this.printerWrapper.sendData(timeout);
  };
  addCut = type => {
    return this.printerWrapper.addCut(type);
  };
  getPrinterSetting = (type, timeout) => {
    return this.printerWrapper.getPrinterSetting(type, timeout);
  };
  getStatus = () => {
    return this.printerWrapper.getStatus();
  };
  addImage = params => {
    return this.printerWrapper.addImage(params);
  };
  addBarcode = params => {
    return this.printerWrapper.addBarcode(params);
  };
  addSymbol = params => {
    return this.printerWrapper.addSymbol(params);
  };
  addCommand = uint8Array => {
    return this.printerWrapper.addCommand(uint8Array);
  };
  addPulse = params => {
    return this.printerWrapper.addPulse(params);
  };
  addTextAlign = params => {
    return this.printerWrapper.addTextAlign(params);
  };
  addTextSize = async params => {
    await this.printerWrapper.addTextSize(params);
  };
  addTextSmooth = smooth => {
    return this.printerWrapper.addTextSmooth(smooth);
  };
  addTextStyle = params => {
    return this.printerWrapper.addTextStyle(params);
  };
  addTextLang = lang => {
    return this.printerWrapper.addTextLang(lang);
  };
  clearCommandBuffer = () => {
    return this.printerWrapper.clearCommandBuffer();
  };
}
exports.Printer = Printer;
//# sourceMappingURL=Printer.js.map