"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrintersDiscovery = void 0;
var _reactNative = require("react-native");
var _index = require("../core/index.js");
var _constants = require("./constants.js");
var _index2 = require("./utils/index.js");
var _index3 = require("../specs/index.js");
class PrintersDiscoveryClass {
  timeout = null;
  status = 'inactive';
  statusListeners = [];
  errorListeners = [];
  start = async ({
    timeout = _constants.DEFAULT_DISCOVERY_TIMEOUT,
    autoStop = true,
    filterOption = {}
  } = {}) => {
    try {
      if (this.status === 'discovering') return;
      if (_reactNative.Platform.OS === 'android' && !(await (0, _index.requestAndroidPermissions)()) || !(await (0, _index.enableLocationAccessAndroid10)())) {
        this.triggerError('PrintersDiscovery.start', new Error(String(_constants.DiscoveryErrorResult.PERMISSION_ERROR)));
        return;
      }
      this.setStatus('discovering');
      await _index3.EscPosPrinterDiscovery.startDiscovery(filterOption);
      if (autoStop) {
        this.stopAfterDelay(timeout);
      }
    } catch (error) {
      this.setStatus('inactive');
      this.triggerError('start', error);
    }
  };
  stop = async () => {
    try {
      if (this.status === 'inactive') return;
      this.clearTimeout();
      await _index3.EscPosPrinterDiscovery.stopDiscovery();
      this.setStatus('inactive');
    } catch (error) {
      this.triggerError('stop', error);
    }
  };
  stopAfterDelay = timeout => {
    this.timeout = setTimeout(() => {
      this.timeout = null;
      this.stop();
    }, timeout);
  };
  clearTimeout = () => {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  };
  onStatusChange = callback => {
    this.statusListeners.push(callback);
    return () => {
      this.statusListeners = this.statusListeners.filter(listener => listener !== callback);
    };
  };
  onError = callback => {
    this.errorListeners.push(callback);
    return () => {
      this.errorListeners = this.errorListeners.filter(listener => listener !== callback);
    };
  };
  onDiscovery = callback => {
    const listener = _index3.EscPosPrinterDiscovery.onDiscovery(printer => {
      callback(printer.map(info => ({
        ...info,
        deviceType: _constants.DiscoveryDeviceTypeMapping[info.deviceType]
      })));
    });
    return () => {
      listener.remove();
    };
  };
  pairBluetoothDevice = async macAddress => {
    if (_reactNative.Platform.OS === 'ios') {
      try {
        await _index3.EscPosPrinterDiscovery.pairBluetoothDevice(macAddress || '');
      } catch (error) {
        throw (0, _index2.getProcessedError)({
          methodName: 'pairBluetoothDevice',
          errorCode: error.message,
          messagesMapping: _constants.PrinterPairBluetoothErrorMessageMapping,
          statusMapping: _constants.PrinterPairBluetoothErrorStatusMapping
        });
      }
    } else {
      return Promise.resolve();
    }
  };
  triggerError = (methodName, error) => {
    const processedError = (0, _index2.getProcessedError)({
      methodName,
      errorCode: error.message
    });
    this.errorListeners.forEach(listener => listener(processedError));
  };
  triggerStatusChange = status => {
    this.statusListeners.forEach(listener => listener(status));
  };
  setStatus = status => {
    this.status = status;
    this.triggerStatusChange(status);
  };
}
function initPrintersClass() {
  return new PrintersDiscoveryClass();
}
const PrintersDiscovery = exports.PrintersDiscovery = initPrintersClass();
//# sourceMappingURL=PrintersDiscovery.js.map