"use strict";

import { Platform } from 'react-native';
import { enableLocationAccessAndroid10, requestAndroidPermissions } from "../core/index.js";
import { DEFAULT_DISCOVERY_TIMEOUT, DiscoveryErrorResult, DiscoveryDeviceTypeMapping, PrinterPairBluetoothErrorMessageMapping, PrinterPairBluetoothErrorStatusMapping } from "./constants.js";
import { getProcessedError } from "./utils/index.js";
import { EscPosPrinterDiscovery } from "../specs/index.js";
class PrintersDiscoveryClass {
  timeout = null;
  status = 'inactive';
  statusListeners = [];
  errorListeners = [];
  start = async ({
    timeout = DEFAULT_DISCOVERY_TIMEOUT,
    autoStop = true,
    filterOption = {}
  } = {}) => {
    try {
      if (this.status === 'discovering') return;
      if (Platform.OS === 'android' && !(await requestAndroidPermissions()) || !(await enableLocationAccessAndroid10())) {
        this.triggerError('PrintersDiscovery.start', new Error(String(DiscoveryErrorResult.PERMISSION_ERROR)));
        return;
      }
      this.setStatus('discovering');
      await EscPosPrinterDiscovery.startDiscovery(filterOption);
      if (autoStop) {
        this.stopAfterDelay(timeout);
      }
    } catch (error) {
      this.setStatus('inactive');
      this.triggerError('start', error);
    }
  };
  stop = async () => {
    try {
      if (this.status === 'inactive') return;
      this.clearTimeout();
      await EscPosPrinterDiscovery.stopDiscovery();
      this.setStatus('inactive');
    } catch (error) {
      this.triggerError('stop', error);
    }
  };
  stopAfterDelay = timeout => {
    this.timeout = setTimeout(() => {
      this.timeout = null;
      this.stop();
    }, timeout);
  };
  clearTimeout = () => {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  };
  onStatusChange = callback => {
    this.statusListeners.push(callback);
    return () => {
      this.statusListeners = this.statusListeners.filter(listener => listener !== callback);
    };
  };
  onError = callback => {
    this.errorListeners.push(callback);
    return () => {
      this.errorListeners = this.errorListeners.filter(listener => listener !== callback);
    };
  };
  onDiscovery = callback => {
    const listener = EscPosPrinterDiscovery.onDiscovery(printer => {
      callback(printer.map(info => ({
        ...info,
        deviceType: DiscoveryDeviceTypeMapping[info.deviceType]
      })));
    });
    return () => {
      listener.remove();
    };
  };
  pairBluetoothDevice = async macAddress => {
    if (Platform.OS === 'ios') {
      try {
        await EscPosPrinterDiscovery.pairBluetoothDevice(macAddress || '');
      } catch (error) {
        throw getProcessedError({
          methodName: 'pairBluetoothDevice',
          errorCode: error.message,
          messagesMapping: PrinterPairBluetoothErrorMessageMapping,
          statusMapping: PrinterPairBluetoothErrorStatusMapping
        });
      }
    } else {
      return Promise.resolve();
    }
  };
  triggerError = (methodName, error) => {
    const processedError = getProcessedError({
      methodName,
      errorCode: error.message
    });
    this.errorListeners.forEach(listener => listener(processedError));
  };
  triggerStatusChange = status => {
    this.statusListeners.forEach(listener => listener(status));
  };
  setStatus = status => {
    this.status = status;
    this.triggerStatusChange(status);
  };
}
function initPrintersClass() {
  return new PrintersDiscoveryClass();
}
export const PrintersDiscovery = initPrintersClass();
//# sourceMappingURL=PrintersDiscovery.js.map